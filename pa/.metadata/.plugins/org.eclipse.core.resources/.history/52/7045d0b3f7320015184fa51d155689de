package pa2;

public class NQueens {
	private StackArray<Integer> board;
	private int n;	// Number of queens
 
    public NQueens(int n){
        this.n = n;
        this.board = new StackArray<Integer>();
    }
    
    public NQueens(){
        this(8);
    }
 
    private boolean isValid(StackArray<Integer> board) {
        if (board.size() == 1) {
            return true;
        }
 
        /**
         * We have to check for diagonal conflicts, y = mx + b
		 *
         * Find the slope of the last queen location on the stack and compare it to
         * all the other queen positions. If the differences in x and y are equal,
         * then the newest queen on the stack conflicts with another queen.
         */
        int size = board.size() - 1;
        int lastX = size;
        int lastY = board.get(lastX);
        for (int i = 0; i < size; i++) {
            // Check horizontal conflict
            if (board.peek() == board.get(i)) {
                return false;
            }
 
            int xDiff = Math.abs(lastX - i);
            int yDiff = Math.abs(lastY - board.get(i));
 
            // Conflict
            if (xDiff == yDiff) {
                return false;
            }
        }
        return true;
    }
 
    private StackArray<Integer> compute(StackArray<Integer> board){
        // If the board size is equal to n we have a valid configuration
        if (this.n == board.size()) {
            return board;
        }
        
        for (int i = 0; i < this.n; i++) {
            // Push i onto the stack
        	board.push(i);
            
            // Check for valid placement
            if (isValid(board)) {
                // Try to place something in the next column
                StackArray<Integer> tmp = this.compute(board);
                
                if (tmp != null) {
                    // Non-null value means a valid configuration. Add to stack.
                    return tmp;
                }
            }
            
            // Backtrack because there is no valid configuration
            board.pop();
        }
        
        // If we reach this point, then we need to backtrack.
        return null;
    }
 
    public String toString(){
        StringBuilder s = new StringBuilder();
        s.append(this.board.toString());
 
        for (int i = 0; i < this.n; i++) {
            s.append("\n");
            for (int j = 0; j < this.n; j++) {
                if (this.board.get(i) == j) {
                    s.append("| " + i + " ");
                } else {
                    s.append("|   ");
                }
            }
            s.append("|");
        }
        
        return s.toString();
    }
    
    public void solve(){
        this.board = compute(new StackArray<Integer>());
    }
    
    public static void main(String argv[]){
        NQueens queens = new NQueens(8);
        queens.solve();
        
        System.out.println(queens);
    }
}
