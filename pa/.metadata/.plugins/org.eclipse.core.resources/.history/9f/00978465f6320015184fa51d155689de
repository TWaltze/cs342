package pa2;

public class NQueens {

	private StackArray<Integer> state;
	private int n;	// Number of queens
 
    public NQueens(int n){
        this.n = n;
        this.state = new StackArray<Integer>();
    }
    public NQueens(){
        this(8);
    }
 
    private boolean isValid(StackArray<Integer> state){
        if (state.size() == 1) {
            return true;
        }
 
        /**
         * We have to check for diagonal conflicts, y = mx + b
		 *
         * Find the slope of the last queen location on the stack and compare it to
         * all the other queen positions. If the differences in x and y are equal,
         * then the newest queen on the stack conflicts with another queen.
         */
        int size = state.size() - 1;
        int lastX = size;
        int lastY = state.get(lastX);
        for(int i = 0; i < size; i++){
            // Check horizontal conflict
            if (state.peek() == state.get(i)) {
                return false;
            }
 
            int xDiff = Math.abs(lastX - i);
            int yDiff = Math.abs(lastY - state.get(i));
 
            // Conflict
            if (xDiff == yDiff) {
                return false;
            }
        }
        return true;
    }
 
    private StackArray<Integer> compute(StackArray<Integer> state){
        // If the state size is equal to n we have a valid configuration
        if(this.n == state.size()){
            return state;
        }
        
        for(int i = 0; i < this.n; i++){
            // Push i onto the stack
            state.push(i);
            
            // Check for valid placement
            if(isValid(state)){
                // Try to place something in the next column
                StackArray<Integer> tmp = this.compute(state);
                if(tmp != null){
                    // Non-null value means a valid configuration. Add to stack.
                    return tmp;
                }
            }
            
            // Backtrack because there is no valid configuration
            state.pop();
        }
        
        // If we reach this point, then we need to backtrack.
        return null;
    }
 
    public String toString(){
        StringBuilder s = new StringBuilder();
        s.append(this.state.toString());
 
        for (int i = 0; i < this.n; i++) {
            s.append("\n");
            for (int j = 0; j < this.n; j++) {
                if (this.state.get(i) == j) {
                    s.append("| " + this.state.get(i) + " ");
                } else {
                    s.append("|   ");
                }
            }
            s.append("|");
        }
        
        return s.toString();
    }
    
    public void solve(){
        this.state = compute(new StackArray<Integer>());
    }
    
    public static void main(String argv[]){
        NQueens queens = new NQueens(8);
        queens.solve();
        
        System.out.println(queens);
    }
}
