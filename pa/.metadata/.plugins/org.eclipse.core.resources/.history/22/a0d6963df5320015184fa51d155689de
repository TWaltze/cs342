package pa2;

public class NQueens {

	private int n;
    private StackArray<Integer> state;
 
    public NQueens(int n){
        this.n = n;
        this.state = new StackArray<Integer>();
    }
    public NQueens(){
        this(8);
    }
 
    private boolean isValid(StackArray<Integer> state){
        if(state.size() == 1){
            return true;
        }
 
 
        /*
        We have to check for diagonal conflicts

        We do this by examining the "slope" of the last queen location on the stack against
        all the other queen positions. If the differences in x and y are equal, then the newest queen on the stack is in
        conflict with another queen.
         */
        int state_size = state.size() - 1;
        int last_x = state_size;
        int last_y = state.get(last_x);
        for(int i = 0; i < state_size; i++){
 
            //check horizontal conflict while we are at it:
            if(state.peek() == state.get(i)){
                return false;
            }
 
            int xdiff = Math.abs(last_x - i);
            int ydiff = Math.abs(last_y - state.get(i));
 
            if(xdiff == ydiff){
                return false;
            }
        }
        return true;
    }
 
    private StackArray<Integer> compute(StackArray<Integer> state){
        // If the state size is equal to n we have a valid configuration
        if(this.n == state.size()){
            return state;
        }
        
        for(int i = 0; i < this.n; i++){
            
            // Push i onto the stack
            state.push(i);
 
            
            // Check for valid placement
            if(isValid(state)){
 
                // Try to place something in the next column
                StackArray<Integer> tmp = this.compute(state);
                if(tmp != null){
                    // Non-null value means a valid configuration. Add to stack.
                    return tmp;
                }
            }
            
            // Backtrack because there is no valid configuration
            state.pop();
 
        }
        
        // If we reach this point, then we need to backtrack.
        return null;
    }
 
    public String toString(){
        StringBuilder s = new StringBuilder();
        s.append(this.state.toString());
 
        for(int i = 0; i < this.n; i++){
            s.append("\n");
            for(int j = 0; j < this.n; j++){
                if(this.state.get(i) == j){
                    s.append("| Q ");
                }
                else{
                    s.append("|   ");
                }
            }
            s.append("|");
        }
        return s.toString();
    }
    
    public void solve(){
        this.state = compute(new StackArray<Integer>());
    }
    
    public static void main(String argv[]){
        NQueens queens = new NQueens(8);
        queens.solve();
        
        System.out.println(queens);
    }

}
